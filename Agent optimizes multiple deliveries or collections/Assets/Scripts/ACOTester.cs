using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ACOTester : MonoBehaviour
{
    // Count variable
    private int count = 0;
    private bool reverse = false;

    public float speed;


    private int stop = 0;
    int current;
    private int pickupcount;

    [SerializeField] private float alpha = 0.0f;
    [SerializeField] private float beta = 0.0000f;
    [SerializeField] private float q = 0.0000f;
    [SerializeField] private float defaultPheromone = 0.0f;
    [SerializeField] private float evaporation = 0.0f;

    // The ACO Controller.
    private ACOCON MyACOCON;

    // Array of possible waypoints.
    List<GameObject> Waypoints = new List<GameObject>();

    // Connections between nodes.
    private List<Connection> Connections = new List<Connection>();

    // The route generated by the ACO algorithm.
    private List<Connection> MyRoute = new List<Connection>();

    // Debug line offset.
    private Vector3 OffSet = new Vector3(0, 0.5f, 0);

    // The Start node for any created route.
    public GameObject StartNode;

    public List<GameObject> Goals = new List<GameObject>();

    // performance
    private float gameTimer;
    private float displayGameTimer;

    private float totalDistance = 0;
    private Vector3 previousLoc;

    // time and distance travelled UI
    public Text GameTime;
    public Text DistanceText;

    public Text Received;
    public Text Speed;

    public int Parcel;

    // The max length of a path created by the ACO.
    public int MaxPathLength;

    // The A* manager.
    private AStarManager AStarManager = new AStarManager();
    // Array of possible waypoints.
    List<GameObject> WaypointsP = new List<GameObject>();

    // Array of waypoint map connections. Represents a path.
    List<List<Connection>> ConnectionArray = new List<List<Connection>>();
    List<Connection> ConnectionArrayOnly = new List<Connection>();

    // Start is called before the first frame update
    void Start()
    {
        // set count value to 0
        pickupcount = 0;
        pick();

        // Initialize MyACOCON with user-defined parameters
        MyACOCON = new ACOCON(alpha, beta, q, defaultPheromone, evaporation);

        GameObject[] GameObjectsWithWaypointTag;
        GameObjectsWithWaypointTag = GameObject.FindGameObjectsWithTag("Waypoint");
        foreach (GameObject waypoint in GameObjectsWithWaypointTag)
        {
            WaypointCON tmpWaypointCon = waypoint.GetComponent<WaypointCON>();
            if (tmpWaypointCon)
            {
                if (tmpWaypointCon.WaypointType == WaypointCON.waypointPropsList.Goal)
                {
                    // We are creating a waypoint map of only the goal nodes. We want our ACO algorithm to create the shortest path between the goal nodes.
                    Waypoints.Add(waypoint);
                }
            }
        }

        // Go through the waypoints and create connections.
        foreach (GameObject waypoint in Waypoints)
        {
            WaypointCON tmpWaypointCon = waypoint.GetComponent<WaypointCON>();
            // Loop through a waypoints connections.
            foreach (GameObject WaypointConNode in tmpWaypointCon.Connections)
            {
                Connection aConnection = new Connection();
                aConnection.SetConnection(waypoint, WaypointConNode, MyACOCON.GetDefaultPheromone());
                Connections.Add(aConnection);
                AStarManager.AddConnection(aConnection);
            }
        }
        MyRoute = MyACOCON.ACO(150, 50, Waypoints.ToArray(), Connections, StartNode, MaxPathLength);

        for (int i = 0; i < (Goals.Count); i++)
        {
            if (i == (Goals.Count - 1))
            {
                ConnectionArray.Add(AStarManager.PathfindAStar(Goals[i], StartNode));
            }
            else
            {
                ConnectionArray.Add(AStarManager.PathfindAStar(Goals[i], Goals[i + 1]));
            }
        }

        Debug.Log("Executing");
        foreach (List<Connection> con in ConnectionArray)
        {
            if (con == null || con.Count == 0)
            {
                Debug.Log("Empty Array");
            }
            foreach (Connection acon in con)
            {
                ConnectionArrayOnly.Add(acon);
            }
        }
    }

    // Draws debug objects in the editor and during editor play (if option set).
    void OnDrawGizmos()
    {
        // Draw path.
        if (MyRoute.Count > 0)
        {
            // ACO Route
            foreach (Connection aConnection in MyRoute)
            {
                Gizmos.color = Color.white;
                Gizmos.DrawLine((aConnection.GetFromNode().transform.position + OffSet),
                (aConnection.GetToNode().transform.position + OffSet));
            }
            // A* path
            foreach (Connection aConnection in ConnectionArrayOnly)
            {
                Gizmos.color = Color.red;
                Gizmos.DrawLine((aConnection.GetFromNode().transform.position + new Vector3(0, 1f, 0)),
                (aConnection.GetToNode().transform.position + new Vector3(0, 1f, 0)));
            }
        }
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        if (count < ConnectionArrayOnly.Count)
        {
            // count time in sec from start to end 
            gameTimer = gameTimer + Time.deltaTime;
            displayGameTimer = Mathf.FloorToInt(gameTimer % 60);
            showPerformance();

            totalDistance += Vector3.Distance(transform.position, previousLoc);
            previousLoc = transform.position;
            showDistance();

            if (!reverse)
            {
                if (transform.position != ConnectionArrayOnly[count].GetToNode().transform.position)
                {
                    Speed.text = "Speed:" + speed.ToString();
                    transform.position = Vector3.MoveTowards(transform.position, ConnectionArrayOnly[count].GetToNode().transform.position, Time.deltaTime * speed);
                    Vector3 relativePos = (ConnectionArrayOnly[count].GetToNode().transform.position) - transform.position;

                    transform.rotation = Quaternion.LookRotation(relativePos);
                }
                else
                {
                    count++;
                }
            }
        }
    }

   void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.CompareTag("Parcel"))
        {
            other.gameObject.SetActive(false);
            pickupcount = pickupcount + 1;
            pick();

            // Decrease speed when picking up a passenger
            DecreaseSpeedByPercentage(10);

            // Check if the collided object has the tag "Car"
            if (other.gameObject.CompareTag("Car"))
            {
                Rigidbody carRigidbody = other.gameObject.GetComponent<Rigidbody>();

                if (carRigidbody != null)
                {
                    // Decrease the speed of cars by 10 percent when colliding with a passenger
                    carRigidbody.velocity *= 0.9f; // 10 percent decrease
                }
            }
        }
    }

    // New method to decrease speed by a percentage
    private void DecreaseSpeedByPercentage(float percentage)
    {
        // Decrease the speed of the taxi by the specified percentage
        speed -= speed * (percentage / 100f);

        // Ensure speed doesn't go below a minimum threshold
        if (speed < 1.0f)
        {
            speed = 1.0f;
        }

        // Update the UI text for speed
        Speed.text = "Speed: " + speed.ToString();
    }
    void pick()
    {
        Received.text = "Package received:" + pickupcount.ToString();
    }

    void showPerformance()
    {
        GameTime.text = "Time: " + displayGameTimer + " sec";
    }

    void showDistance()
    {
        DistanceText.text = "Distance: " + totalDistance.ToString("f0") + "m";
    }
}